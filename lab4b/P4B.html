<HTML>
<HEAD>
<TITLE>Project 4B</TITLE>
</HEAD>
<BODY>
<CENTER>
<H1>Project 4B<br>
Beaglebone Sensors</H1>
</CENTER>

<H2>INTRODUCTION:</H2>
<P>
One of the things that makes small, low-power-consumption
systems interesting is ability they give us to create software
that interacts with people in the physical world.
The input side of those interactions is via a variety of local sensors
(e.g. for sound, light, temperature, position, motion, pressure).
The output side can be sensory (e.g. sound, lights, low power displays)
or physical (e.g. mechanical actuators), or (through digital and
analog outputs) any other controllable device.
Building interactive personal appliances requires us to be able to
communicate with the types of sensors, indicators and actuators that
can be connected to such systems.
</P>
<P>
In this project we will create applications that run in an embedded system,
read data from external sensors, and log the results.
</P>

<H2>RELATION TO READING AND LECTURES:</H2>
<P>
This project is an introductory exploration of technologies and services not 
covered in the reading and lectures.
</P>

<H2>PROJECT OBJECTIVES:</H2>
<UL>
    <LI> Primary: Demonstrate the ability to design, build and debug interactive 
    	applications on an embedded system.</LI>
    <LI> Primary: Develop the ability to work with embedded system sensors and actuators
         through standard tool kits.</LI>
    <LI> Primary: Gain experience with the processing of Digital and Analog inputs
    	 on an embedded system.</li>
</UL>

<H2>DELIVERABLES:</H2>
A single compressed tarball (<tt>.tar.gz</tt>) containing:
<UL>
    <LI> C source files for an embedded application that builds and runs (with no errors
     	or warnings) on a Beaglebone.
    <li> A <tt>Makefile</tt> to build and test your application.
	 The higher level targets should include:
	<ul>
		<li>default ... build your program
		    (compiling with the <strong><tt>-Wall</tt></strong> and 
		    <strong><tt>-Wextra</tt></strong> options).
		    </li>
		<li><strong>check</strong> ... execute an automated smoke-test of your
			application to see if it runs and can talk to its sensors/actuators.</li>
		<li><strong>clean</strong> ... delete all programs and output generated by the Makefile</li>
		<li><strong>dist</strong> ... (runnable on a Linux desktop or server) create the deliverable tarball</li>
	</ul></li>
    	Note that this <tt>Makefile</tt> is intended to be executed on a Beaglebone.
    <li> a <tt>README</tt> file containing:
	<ul>
		<li> descriptions of each of the included files</li>
		<li> any other comments on your submission 
			submission that you would like to bring to our attention 
	 		(e.g. research, limitations, features, testing methodology).</LI>
	</ul></li>
</UL>

<H2>PREPARATION:</H2>
<P>
<ul>
   <li> If you have not already done so, look at the documentation for the
	<A href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</A>
	system call 
	or the <tt>O_NONBLOCK</tt> option used with the
	<A href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</A>
	system call or
	<A href="http://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl(2)</A>
	<TT>F_SETFL</tt> operation.
   <li> Read the documentation on the 
   	<A href="http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2">Grove Temperature Sensor</A>,
	and the algorithm for converting a reading into a temperature.</li>
   <li> Review the documentation for the
   	<a href="https://iotdk.intel.com/docs/master/mraa/">MRAA</A>
	library, an open source, platform independent library for embedded system I/O. (The MRAA page does not explicitly list the Beaglebone
Green Wireless, the device you will be using, as supported, but it is supported.) 
	Also read the
	<a href="https://drive.google.com/drive/folders/0B6dyEb8VXZo-N3hVcVI0UFpWSVk">General Purpose and Analog I/O</A> 
	tutorial that discusses the particular classes you will be using.  These classes include the functions you will be using to read from
	the temperature sensor and button.  
	(Note that to link with this library you will have to add <tt>-lmraa</tt> 
	 to your library search list).
   <li> Read the instructions that came with your Grove Starter Kit.
        They include information on all of your sensors and instructions on
	where to plug each in to the Base Shield.</li>
   <li>	Attach your Grove Base Shield 
   	(a plug-on daughter-board with connectors for all of your sensors) to your Beaglebone/Arduino board.</li>
   <li> Attach your Grove Temperature Sensor to the A0 connector on your base shield.</li>
   <li> Attach your Grove Button to the D3 connector on your base shield.</li>
   <li> Power-up your Beaglebone and confirm that you can still log in and trasfer files to it.</li>
</ul>
</P>

<H2>PROJECT DESCRIPTION:</H2>
<P>
Write a program (called <tt>lab4b</tt>) that:
<ul>
   <li> builds and runs on your Beaglebone.</li>
   <li> uses the AIO functions of the MRAA library to get readings from your temperature sensor.</li>
   <li>	samples a temperature sensor at a configurable rate (defaulting to 1/second, and controlled
   	by an optional <tt>--period=</tt># command line parameter that specifies a sampling 
	interval in seconds).</li>
   <li> converts the sensor value into a temperature.  By default, temperatures should be
        reported in degrees Fahrenheit, but this can be controlled with an optional
	<tt>--scale=C</tt> (or <tt>--scale=F</tt>) command line parameter.</li>
   <li> creates a report for each sample that includes:
   	<ul>
	   <li>	time of the sample (e.g. <tt>17:25:58</tt>) in the local timezone</li>
	   <li> a single blank/space</li>
	   <li> a decimal temperature in degrees and tenths (e.g. <tt>98.6</tt>)
	   <li> a newline character (<em>\n</em>)
	</ul></li>
   <li> writes that report to the stdout (fd 1).</li>
   <li> appends that report to a logfile (which it creates on your Beaglebone) if that logging has been enabled
   	with an optional <tt>--log=</tt><em>filename</em> parameter.</li>
   <li> uses the GPIO functions of the MRAA library to samples the state of the button 
   	(from your Grove sensor kit) and when it is pushed ...
   	<ul>
	   <li> outputs (and logs) a final sample with the time and the string <tt>SHUTDOWN</tt> 
	   	(instead of a temperature).</li>
	   <li> exits</li>
	</ul>
   </li>
   <li> Your program can assume that the sensors are connected as recommended by the Grove
        documentation:
	<ul>
		<li>The temperature sensor to Analog input 0.</li>
		<li>The push-button to Digital input 3.</li>
	</ul>
   </li>
</ul>
</p>
<P>
Note that we want you to use MRAA AIO/GPIO functions to access your sensors, and not the (more powerful
and convenient) Grove library functions.  The Grove library hides all of the details of embedded I/O, 
sampling and signal interpretation, but only works for the Grove Sensors.  
We want you to get experience with direct control of and access to the digital and analog I/O pins.
</P>
<P>
Many people have observed that the recommended calibration constants appear to be off by
ten degrees or more.  Every sensor (including the ones that will be used when we grade your submissions)
seems to read differently.
</p>
<P>
The time returned from <em>localtime(3)</em> will only be in the correct timezone if you have
correctly configured the local timezone on your Beaglebone.
</P>
Extend your program to (in parallel with generating reports) accept the following commands from stdin:
<ul>
   <li> <tt><strong>SCALE=F</strong></tt><br>
   	This command should cause all subsequent reports to be generated in degrees Fahrenheit.
   </li>
   <li> <tt><strong>SCALE=C</strong></tt><br>
   	This command should cause all subsequent reports to be generated in degrees Centegrade
   </li>
   <li> <tt><strong>PERIOD=</strong></tt><em>seconds</em><br>
   	This command should change the number of seconds between reporting intervals.
	It is acceptable if this command does not take effect until after the next
	report.
   </li>
   <li> <tt><strong>STOP</strong></tt><br>
   	This command should cause the program to stop generating reports, but continue
	processing input commands.
	If the program is not generating reports, merely log receipt of the command.
   </li>
   <li> <tt><strong>START</strong></tt><br>
   	This command should cause the program to, if stopped, resume generating reports.
	If the program is not stopped, merely log receipt of the command.
   </li>
   <li> <tt><strong>OFF</strong></tt><br>
   	This command should, like pressing the button, output (and log) a time-stamped <tt>SHUTDOWN</tt> message 
	and exit.
   </li>
</ul>
<P>
All received commands will be terminated by a new-line character ('<em>\n</em>').
Note that when your program is tested (by the sanity checker or grading program)
stdin will not be a console, but a pipe.  
A single read may return a partial line or multiple lines.
Make sure that your program buffers and lexes its input,
and does not assume that one call to <em>read(2)</em> will return one command.
</P>
<P>
If logging is enabled, all received commands should be appended to the log file (exactly as
received, with no timestamp) but not displayed to standard output.  A sample log is 
shown below:
</p>
<pre><tt>
	11:37:41 98.6
	11:37:42 98.6
	11:37:43 98.6
	PERIOD=5
	11:37:44 98.6
	11:37:49 98.6
	11:37:54 98.6
	SCALE=C
	11:37:59 37.0
	11:38:04 37.0
	STOP
	START
	11:38:19 37.0
	11:38:24 37.0
	OFF
	11:38:27 SHUTDOWN
</tt></pre>
<P>
If you are typing commands to your program, you may see the echos interspersed with 
temperature reports.  This is unimportant, because they should be correctly distinct
in your log, and when we test your submission, the input will becoming from a program
rather than a console.
</P>
<P>
The sanity check script will send a series of commands to your program, and some
implementations process all the commands before generating any reports.  To make
sure this doesn't happen, you should generate your first report before you start
processing input commands.  Again, this will not be an issue during testing because
there will be delays between the commands when we test your program.
</P>
<P>
You could implement this program with separate threads for sensor polling and command processing,
but the computation associated with each operation is so small that you may find it much simpler
to use a single thread (and polling or non-blocking I/O) to avoid hanging on standard input for
commands that only rarely arrive.  A poll system call cannot tell you that the button has
been pushed, but GPIO pin read is a non-blocking operation, so you can simply read the button
status once per second.
</P>
<P>
To facilitate development and testing you might find it helpful to write your program to, if compiled with a special 
(<tt>-DDUMMY</tt>) define, include mock implementations for the <tt>mraa_aio_</tt> and 
<tt>mraa_gpio_</tt> functionality. Doing so will enable you to do most of your testing on your regular computer.  
When you are satisfied that it works there, modify your Makefile run the command "<tt>uname -r</tt>", check for the 
presence of the string "<tt>beaglebone</tt>" in that output, and if not found, build with a rule
that passed the <tt>-DDUMMY</tt> flag to <em>gcc</em>.
</p>

<H2>SUBMISSION:</H2>
<p>
Your tarball should have a name of the form <tt>lab4b-</tt><em>studentID</em><tt>.tar.gz</tt>.
You can sanity check your submission with this 
<A href="P4B_check.sh">test script</A>.  
It should run on a Beaglebone, but if your program is (as above) runnable on your Linux
development system, the sanity check script should also run there.
There will be no manual re-grading on this project.
Submissions that do not pass the test script are likely to receive very low scores.
</p>
<P>
Your <strong>README</strong> file (and all source files) must include lines of the form:
<ul>
	<strong>NAME:</strong> <em>your name</em><br>
	<strong>EMAIL:</strong> <em>your email</em><br>
	<strong>ID:</strong> <em>your student ID</em>
</ul>
And, if slip days are allowed on this project, and you use some:
<ul>
	<strong>SLIPDAYS:</strong> <em>your student ID</em>,<em>#days</em>
</ul>
</P>

<H2>GRADING:</H2>
<P>
Points for this project will be awarded:
</P>
<div align="center">
<table><tbody>
<tr> <th>value</th>	<th align="left">feature</th></tr>

<tr> <td></td>		<th align="left">Packaging and build (10% total)</th></tr>
<tr> <td>3%</td>	<td>un-tars expected contents</td></tr>
<tr> <td>3%</td>	<td>clean build of correct program w/default action (no warnings)</td></tr>
<tr> <td>2%</td>	<td>Makefile has working <tt>clean</tt>, <tt>check</tt>, <tt>dist</tt> targets</td></tr>
<tr> <td>2%</td>	<td>reasonableness of <tt>README</tt> contents</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Sensor Functionality (25% total)</th></tr>
<tr> <td>10%</td>	<td>samples and reports temperature</td></tr>
<tr> <td>5%</td>	<td>reports Fahrenheit temperature (by default)</td></tr>
<tr> <td>5%</td>	<td>reports Centegratde temperature (w/<tt>--scale=</tt> parameter)</td></tr>
<tr> <td>5%</td>	<td>samples button and exits</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Control Functionality (40% total)</th></tr>
<tr> <td>10%</td>	<td>command and data logging</td</tr>
<tr> <td>10%</td>	<td><tt>START</tt>/<tt>STOP</tt> commands</td></tr>
<tr> <td>10%</td>	<td><tt>PERIOD=</tt><em>#</em> command</td></tr>
<tr> <td>5%</td>	<td><tt>SCALE=C</tt>/<tt>F</tt> commands</td></tr>
<tr> <td>5%</td>	<td><tt>OFF</tt> command</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Code Review (25%)</th></tr>
<tr> <td>10%</td>	<td>use of AIO functions to read temperature</td></tr>
<tr> <td>10%</td>	<td>use of GPIO functions to read button</td></tr>
<tr> <td>5%</td>	<td>general readability and understandability</td></tr>
</tbody></table>
</div>

</BODY>
</HTML>
